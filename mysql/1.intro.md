# 缓存

# 锁与并发
## 锁类型：
1. 读写锁，读锁（共享锁），写锁（排他锁）
## 锁粒度
1. 行锁
2. 表锁
## 乐观悲观
乐观锁，假设不会发生冲突，修改数据时才锁事务。用version来锁定
悲观锁，查询后直接用数据库锁把事务锁起来

# 事务
## 事务的特性ACID
1. A原子性，不可分的最小单元，要么没执行，要么全部执行
2. C一致性，数据库总是从一个一致性的状态转换到另一个一致性的状态。
3. I隔离性，事务的修改在提交前，对于另一个事务是不可见的
4. D持久性，事务提交，修改永久修改

##四种问题
1. 脏读，事务A读到了事务B修改的中间数据
2. 不可重复读，由于事务A改变数据a。事务B中前后两次读取a的值不一致。第一次事务A没有提交，第二次事务A已提交
3. 幻读，事务A会insert，事务B第二次读取读取到了新的行

## 隔离级别
1. 读未提交，最低的等级，会存在脏读，不加读锁
2. 读已提交，避免脏读，读加读锁，执行完语句后释放
3. 可重复读，避免不可重复读（mvcc机制可以避免幻读，间隔锁），读加读锁，事务提交之前不释放锁，事务完成才释放锁
4. 串行化，避免所有上述问题，并发性差

## 死锁

## 事务日志
提高事务效率，修改内存拷贝，然后持久化到硬盘上。顺序io追加
redo log 记录事务执行过程中的节点
undo log 回滚行记录到某个版本，保存了事务执行前的log

# 存储数据结构

# MVCC
行锁的变种，不同引擎实现方式不同。

# 范式
1. 列原子性
2. 实体属性完全依赖主关键字不能仅依赖其他属性
3. 非主属性不依赖于其他非主属性

# 约束
非空
去重
主键
外键
check范围

# 存储过程
一些预编译的sql语句，代替大量的sql，降低网络通信量，防止跨站脚本攻击

# 分库分表
分表 sharding，同机器不同表
分库 sharding，不同机器不同库

# 优化
加缓存，主从复制，读写分离，垂直拆分，水平拆分

# 索引相关

聚簇索引：将数据和索引放到一起存储，索引结构的叶子节点保留了数据行。
非聚簇索引：将数据进和索引分开存储，索引叶子节点存储的是指向数据行的地址。

覆盖索引：查询列从索引里就能获得，解决非聚簇索引回表查询
